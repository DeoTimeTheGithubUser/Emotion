package co.q64.jstx.compiler;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.google.auto.factory.AutoFactory;
import com.google.auto.factory.Provided;

import co.q64.jstx.annotation.Constants.Author;
import co.q64.jstx.annotation.Constants.Name;
import co.q64.jstx.annotation.Constants.Version;
import co.q64.jstx.lang.opcode.Opcodes;
import lombok.Getter;

@AutoFactory
public class CompilerOutput {
	private String author;
	private String version;
	private String name;
	private Opcodes opcodes;
	private @Getter boolean success;
	private @Getter String error;
	private List<String> compiledLines, instructionLines;

	protected CompilerOutput(String author, String name, String version, Opcodes opcodes) {
		this.author = author;
		this.version = version;
		this.name = name;
		this.opcodes = opcodes;
	}

	protected CompilerOutput(@Provided @Author String author, @Provided @Name String name, @Provided @Version String version, @Provided Opcodes opcodes, String error) {
		this(author, name, version, opcodes);
		this.error = error;
		this.success = false;
	}

	protected CompilerOutput(@Provided @Author String author, @Provided @Name String name, @Provided @Version String version, @Provided Opcodes opcodes, List<String> compiledLines, List<String> instructionLines) {
		this(author, name, version, opcodes);
		this.compiledLines = compiledLines;
		this.instructionLines = instructionLines;
		this.success = true;
	}

	public List<String> getDisplayOutput() {
		List<String> result = new ArrayList<>();
		if (success) {
			int offsetLength = 0;
			for (String s : instructionLines) {
				if (s.length() > offsetLength) {
					offsetLength = s.length();
				}
			}
			result.add(getProgram());
			result.add(new String());
			result.add("Size: " + getProgram().length() + " bytes");
			result.add("Instructions: " + instructionLines.size());
			result.add(new String());
			for (int i = 0; i < compiledLines.size(); i++) {
				if (instructionLines.size() <= i) {
					continue;
				}
				String instruction = instructionLines.get(i);
				String offset = new String();
				for (int u = 0; u < offsetLength - instruction.length(); u++) {
					offset += " ";
				}
				String compiled = compiledLines.get(i);
				if (compiled.equals(" ")) {
					compiled = "<whitespace character>";
				}
				result.add((i + 1) + ": " + instruction + offset + " => " + compiled);
			}
			result.add(new String());
			offsetLength = 0;
			for (String s : compiledLines) {
				if (s.length() > offsetLength) {
					offsetLength = s.length();
				}
			}
			for (int i = 0; i < compiledLines.size(); i++) {
				if (instructionLines.size() <= i) {
					continue;
				}
				String instruction = instructionLines.get(i);
				String compiled = compiledLines.get(i);
				String offset = new String();
				String description = opcodes.getDescription(instruction);
				if (instruction.startsWith("load")) {
					description = "Push literal " + instruction.substring(5);
				}
				for (int u = 0; u < offsetLength - compiled.length(); u++) {
					offset += " ";
				}
				if (compiled.equals(" ")) {
					compiled = "<whitespace character>";
				}
				result.add(compiled + offset + " # " + description);
			}
		} else {
			result.add(error);
		}
		result.add(new String());
		result.add("Generated by " + name + " compiler version " + version + " by " + author + ".");
		return result;
	}

	public String getProgram() {
		return compiledLines.stream().collect(Collectors.joining());
	}
}
