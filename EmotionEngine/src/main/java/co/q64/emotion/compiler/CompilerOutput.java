package co.q64.emotion.compiler;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.google.auto.factory.AutoFactory;
import com.google.auto.factory.Provided;

import co.q64.emotion.annotation.Constants.Author;
import co.q64.emotion.annotation.Constants.Version;
import co.q64.emotion.ast.ASTBuilder;
import co.q64.emotion.lang.opcode.Opcodes;
import lombok.Getter;

import javax.inject.Inject;

public class CompilerOutput {
    protected @Inject @Author String author;
    protected @Inject @Version String version;
    protected @Inject Opcodes opcodes;
    protected @Inject ASTBuilder ast;

    private @Getter boolean success;
    private @Getter String error;
    private List<InstructionInfo> instructions;

    protected @Inject CompilerOutput() {}

    public CompilerOutput error(String error) {
        this.error = error;
        this.success = false;
        return this;
    }

    public CompilerOutput success(List<InstructionInfo> instructions) {
        this.instructions = instructions;
        this.success = true;
        return this;
    }

    public List<String> getDisplayOutput() {
        List<String> result = new ArrayList<>();
        if (success) {
            int offsetLength = 0;
            for (InstructionInfo info : instructions) {
                if (info.instruction().length() > offsetLength) {
                    offsetLength = info.instruction().length();
                }
            }
            result.add(getProgram());
            result.add(new String());
            result.add("Size: " + getProgram().codePointCount(0, getProgram().length()) + " bytes");
            result.add("Instructions: " + instructions.size());
            result.add(new String());
            for (InstructionInfo info : instructions) {
                String offset = new String();
                for (int u = 0; u < offsetLength - info.instruction().length(); u++) {
                    offset += " ";
                }
                String compiled = info.compiled();
                if (compiled.equals(" ")) {
                    compiled = "<whitespace character>";
                }
                result.add(info.line() + ": " + info.instruction() + offset + " => " + compiled);
            }
            result.add(new String());

            result.addAll(getExplanation());
        } else {
            result.add(error);
        }
        result.add(new String());
        if (isSuccess() && getProgram().length() > 0) {
            result.add("Debug AST: " + ast.build(null, getProgram()).toString());
            result.add(new String());
        }
        result.add("Generated by the Emotion compiler version " + version + " by " + author + ".");
        return result;
    }

    public List<String> getExplanation() {
        List<String> result = new ArrayList<>();
        for (InstructionInfo info : instructions) {
            String description = opcodes.getDescription(info.instruction());
            if (info.instruction().startsWith("load")) {
                if (info.instruction().length() < 6) {
                    description = "Push empty";
                } else {
                    description = "Push literal " + info.instruction().substring(5);
                }
            }
            result.add(info.compiled() + " " + description);
        }
        return result;
    }

    public String getProgram() {
        return instructions.stream().map(InstructionInfo::compiled).collect(Collectors.joining());
    }
}
